{"version":3,"sources":["components/card/card.component.jsx","components/card-list/card-list.component.jsx","components/search-box/search-box.component.jsx","App.js","reportWebVitals.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsterz","map","SearchBox","placeholder","handleChange","type","onChange","App","e","setState","searchField","target","value","state","monsters","fetch","then","response","json","users","this","filteredMonsters","filter","aMonster","toLowerCase","includes","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"iUAWaA,EAAO,SAACC,GAAD,OAChB,sBAAKC,UAAU,iBAAf,UACI,qBAAKC,IAAI,UAAUC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BACtB,mCAAML,EAAMI,QAAQE,KAApB,OACA,4BAAIN,EAAMI,QAAQG,YCcbC,EAAW,SAACR,GAErB,OACI,qBAAKC,UAAU,YAAf,SAEQD,EAAMS,SAASC,KAAI,SAAAN,GAAO,OACtB,cAAC,EAAD,CAAyBA,QAASA,GAArBA,EAAQC,UClB5BM,G,MAAY,SAAC,GAAD,IAAEC,EAAF,EAAEA,YAAaC,EAAf,EAAeA,aAAf,OACrB,uBAAQC,KAAK,SACLb,UAAU,SACVW,YAAaA,EACbG,SAAUF,MC0KPG,E,kDAvLb,aAAe,IAAD,8BACV,gBA+IFH,aAAe,SAAAI,GACb,EAAKC,SAAS,CAACC,YAAaF,EAAEG,OAAOC,SA3HrC,EAAKC,MAAQ,CACXC,SAAU,GACVJ,YAAa,IAxBL,E,qDAkCd,WAAqB,IAAD,OAoBlBK,MAAM,8CACLC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAG,GAAK,OAAI,EAAKV,SAAS,CAACK,SAAUK,S,oBAiG1C,WAAS,MAS2BC,KAAKP,MAA/BC,EATD,EASCA,SAAUJ,EATX,EASWA,YACZW,EAAmBP,EAASQ,QAAO,SAAAC,GAAQ,OAC7CA,EAAS1B,KAAK2B,cAAcC,SAASf,EAAYc,kBAGnD,OACE,sBAAKhC,UAAU,MAAf,UACE,kDACA,cAAC,EAAD,CACEW,YAAc,kBACdC,aAAgBgB,KAAKhB,eAEvB,cAAC,EAAD,CAAUJ,SAAUqB,W,GA/KZK,aCKHC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBb,MAAK,YAAkD,IAA/Cc,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.16bfb950.chunk.js","sourcesContent":["import React from 'react';\r\nimport './card.styles.css'\r\n\r\n// set=set2 is called a url parameter, here, we are asking to use this set of images\r\n// found on the website\r\n// &size=180x180 --> we added it to the url\r\n// ${props.monster.id} --> used to choose different images based on the unique id\r\n// of each monster\r\n\r\n// the robo hash or url is considered an API\r\n\r\nexport const Card = (props) => (\r\n    <div className=\"card-container\">\r\n        <img alt=\"monster\" src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`} />\r\n        <h2> {props.monster.name} </h2>\r\n        <p>{props.monster.email}</p>\r\n    </div>\r\n)\r\n\r\n","// the .component in file name is not necessary, we added it to tell what kind of file that is\r\nimport React from 'react';\r\nimport './card-list.styles.css'\r\n\r\nimport { Card } from '../card/card.component';\r\n\r\n// a functional component\r\n// props is the parameter that we gonna take from our functional component\r\n// props would be any parameter that we'd pass into our CardList component in App.js file\r\n\r\n// import this component in App.js\r\n\r\n// props is a random name, we can choose whatever we want also\r\n\r\n/* \r\n <div className='card-list'>\r\n            {props.children}\r\n    </div>\r\n*/\r\n\r\n/* \r\n<div className='card-list'>\r\n            {\r\n                props.monsterz.map(monster => \r\n                    <h1 key = {monster.id}> {monster.name} </h1>\r\n                )\r\n            }\r\n        </div>\r\n*/\r\nexport const CardList = (props) => {\r\n    //console.log(props);\r\n    return (\r\n        <div className='card-list'>\r\n            {\r\n                props.monsterz.map(monster => \r\n                    <Card key = {monster.id} monster={monster}/>\r\n                )\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\n// return (<div>Helloyy</div>)","import React from 'react';\r\n\r\nimport './search-box.styles.css';\r\n\r\n/* \r\nFunctional components, unlike class components, such as App.js component\r\ndon't have access to state because they don't have access to constructor which is a\r\nclass method on our Component that we imported from React that we extend our class from,\r\nthey also don't have access to lifecycle methods because we don't always need to use them \r\n\r\nA functional component is a one that takes some props and returns some HTML\r\n\r\nSo if you don't need access to state or lifecycle methods \r\n, just use functional components [becasue it's easier to test and read],\r\notherwise, use class components\r\n*/\r\n\r\nexport const SearchBox = ({placeholder, handleChange}) => (\r\n    <input  type='search' \r\n            className=\"search\" \r\n            placeholder={placeholder} \r\n            onChange={handleChange} \r\n  />\r\n)\r\n\r\n/* e =>\r\n        this.setState(\r\n          {searchField: e.target.value}\r\n        ) */","//import logo from './logo.svg'; // not used anymore, giving a warning\nimport './App.css';\nimport { Component } from 'react'; // was added automatically\n\nimport {CardList} from './components/card-list/card-list.component'\nimport {SearchBox} from './components/search-box/search-box.component'\n\nclass App extends Component {\n  constructor() {\n      super();\n      // array of objects\n      /*\n      this.state = {\n        monsters: [\n          {\n            name: 'Frankenstein',\n            id: 'monster1'\n          },\n          {\n            name: 'Dracula',\n            id: 'monster2'\n          },\n          {\n            name: 'Zombie',\n            id: 'monster3'\n          }\n        ]\n      };*/\n\n      // without hard coding users\n      this.state = {\n        monsters: [],\n        searchField: ''\n      };\n\n      //this.handleChange = this.handleChange.bind(this);\n  }\n\n  // Lifecycle methods:\n  // when this component mounts\n  // it is when React puts our components on the page & renders it to the DOM for the 1st time\n  // when it does that, it runs whatever code found inside componentDidMount\n  componentDidMount() {\n    // make API request to a url (fetching)\n    /*fetch('https://jsonplaceholder.typicode.com/users')\n    .then(response => response.json())\n    .then(users => console.log(users));*/\n\n    // .then: promises\n    // previously, they used to use call back functions to throw errors or to proceed\n    // nested callbacks --> callback hell (since it's difficult to read and debug)\n    // they were asynchronous functions: we don't know when they'll complete\n    // each function depends on the result or return of the previous one\n\n    // promise: promise that this object will have a result value: resolved or rejected value\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n    // resolve: when API call is successful\n    // rejected: when API call returns an error\n    // .then: gets the resolved value\n    // .catch: returns the error or rejected value\n\n    // response is a random name, we can name another, same for users\n    fetch('https://jsonplaceholder.typicode.com/users')\n    .then(response => response.json())\n    .then(users => this.setState({monsters: users}));\n  }\n\n  // the reason why we need a unique key is because React needs to know which\n  // element it needs to update if one of the elements in the array has a value that changes\n  // so that it does not re-render everything\n  // React is smart\n  // https://www.pluralsight.com/guides/how-to-use-the-map()-function-to-export-javascript-in-react\n\n  // when to use the key attribute:\n  // Anytime you use the map() function inside of render, \n  // or you have a list of the same jsx elements one after another, \n  // they need a key attribute (and CRA will warn you about it if you miss it)\n\n  // map(): explained in Arrays.js\n\n  // <h1 key = {monster.id}> {monster.username} </h1>\n  // we can get any key-value pair we want from the json in the link\n\n  // monster is a random name, we can choose another\n\n  // <CardList age=\"22\"/>\n  // moving on to children props for a better experience\n\n  /* \n  <CardList>\n    <h2>Mahmoud</h2>\n  </CardList>\n  */\n\n  /* \n  <CardList monsterz={this.state.monsters}>\n          {\n            this.state.monsters.map(monster => \n                <h1 key = {monster.id}> {monster.name} </h1>\n            )\n          }\n          </CardList>\n  */\n\n  // now the CardList component is responsible for generating our monsters cards,\n  // and not our App component\n\n  // e in onChange represents the synthetic event\n  // a native event that the browser uses to do all kinds of different things\n\n  // <input type='search' placeholder=\"Search monsters\" onChange={e => console.log(e)} />\n  // <input type='search' placeholder=\"Search monsters\" onChange={e => console.log(e.target)} />\n  // <input type='search' placeholder=\"Search monsters\" onChange={e => console.log(e.target.value  )} />\n  \n  // normally if we want to check if the state is updated, we console log after the line\n  // which updates the state, but, the searchField key in our case is 1 letter behind\n  // if you type 'a', the search field shows empty string (searchField not updated), \n  // if we type another 'a' it shows only 1 'a'\n  // this is because setState is an asynchronous function call\n  // synchronous: is an action that we expect that will happen almost immediatly\n  // and js knows the amount of time this action or function will take,\n  // so js will wait for that thing to finish before it continues running the rest of the code\n  // asynchronous: is an action or event is something that take an indefinite amount of time\n  // that js doesn't know; so it runs the rest of the code first, and when the async event\n  //  finishes, it then runs this finished event\n\n  /* <input type='search' placeholder=\"Search monsters\" onChange={e => {\n            this.setState({searchField: e.target.value});\n            console.log(this.state);\n            }} \n          /> \n  */\n  // instead, we can use a callback function as a property in setState, which will happen\n  // after setState is finished (after updating the state)\n\n  /* \n  <input type='search' placeholder=\"Search monsters\" onChange={e =>\n                this.setState(\n                  {searchField: e.target.value}, () => console.log(this.state)\n                )\n            } \n          />\n  */\n\n    /*\n    // written as a class method instead of arrow function for reusability purpose\n    handleChange(e) {\n      // this in this case will give error upon search since the context of this\n      // in this case is this method itself and not the App class, so we use binding to solve\n      // the problem\n      this.setState({searchField: e.target.value});\n    }*/\n    handleChange = e => {\n      this.setState({searchField: e.target.value});\n    };\n // onChange event here is JSX (synthetic event) != onchange in a regular hmtl element\n // the 1st updates the state, updates the virtual DOM, then the main DOM is updated\n // accordingly, the 2nd updates the main DOM directly!\n // Synthetic event: a fake event that we pretend that it's a DOM event, but it's\n // something that our React robot is telling us\n \n  render() {\n    // destructuring: pull properties out of an object and set them to constants\n    // it is the equivalent to\n    // const monsters = this.state.monsters;\n    // const searchField = this.state.searchField;\n\n    // we defined 2 new arrays to avoid overwriting on the main one\n    // React rerenders the component everytime a change happens in the searchField\n    // In react, no need to hide or show cards explicitly (as we were used to do traditionally)\n    const { monsters, searchField } = this.state;\n    const filteredMonsters = monsters.filter(aMonster =>\n        aMonster.name.toLowerCase().includes(searchField.toLowerCase())\n      );\n\n      return (\n        <div className=\"App\">\n          <h1>Monsters Rolodex</h1>\n          <SearchBox\n            placeholder = 'search monsters'\n            handleChange = {this.handleChange}\n          />\n          <CardList monsterz={filteredMonsters}></CardList>\n        </div>\n      );\n      // <CardList monsterz={this.state.monsters}></CardList>\n      // handleChange = {e => this.setState({searchField: e.target.value})}\n  }\n\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}